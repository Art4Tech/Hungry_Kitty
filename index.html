<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hungry Kitty v2</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #2d3436; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
        }
        
        canvas { 
            display: block; 
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 100;
        }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 15, 20, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            z-index: 200;
            transition: opacity 0.5s;
            backdrop-filter: blur(5px);
            padding: 20px;
            box-sizing: border-box;
        }
        
        .hidden { display: none !important; }
        
        h1 { color: #a29bfe; text-shadow: 0 0 20px #6c5ce7; font-size: 2.5rem; margin: 0 0 10px 0; text-align: center; }
        p { color: #dfe6e9; text-align: center; font-size: 1.1rem; opacity: 0.9; margin: 5px; max-width: 600px; }
        
        .emoji-art { font-size: 4rem; margin: 15px 0; animation: float 3s infinite ease-in-out; }
        @keyframes float { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-10px);} }

        /* CONTROLS */
        .slider-container {
            margin-top: 20px;
            text-align: center;
            color: #dfe6e9;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 15px;
            border: 1px solid rgba(162, 155, 254, 0.3);
        }
        
        input[type=range] { -webkit-appearance: none; width: 200px; height: 8px; border-radius: 5px; background: #dfe6e9; outline: none; margin: 10px 0; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #6c5ce7; cursor: pointer; }

        button {
            margin-top: 30px; padding: 15px 40px; font-size: 1.3rem;
            background: linear-gradient(135deg, #6c5ce7, #a29bfe); border: none; color: white; border-radius: 50px; cursor: pointer;
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.5); font-weight: bold;
        }
        button:active { transform: scale(0.95); }

        #hud {
            padding: 20px; font-size: 1.5rem; font-weight: bold; color: white;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.8); display: flex; justify-content: space-between; width: 100%; box-sizing: border-box;
        }
        
        #safety-msg {
            color: #fab1a0; font-size: 1.2rem; background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 20px;
            opacity: 0; transition: opacity 0.5s;
        }

        #stamina-container {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 20px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,255,255,0.5);
            border-radius: 10px; overflow: hidden; z-index: 150;
        }
        #stamina-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #f1c40f, #f39c12); transition: width 0.1s linear; }
        #stamina-label { position: absolute; top: -25px; left: 0; width: 100%; text-align: center; color: white; font-size: 0.9rem; font-weight: bold; text-shadow: 1px 1px 0 #000; }

        #footer {
            position: absolute; bottom: 10px; width: 100%; text-align: center; color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem; pointer-events: none; z-index: 500; text-shadow: 1px 1px 2px black;
        }

        #controls-layer {
            position: absolute; bottom: 20px; width: 100%; height: 150px; pointer-events: none;
            display: flex; justify-content: space-between; padding: 0 30px; box-sizing: border-box;
        }

        #joystick-zone {
            width: 140px; height: 140px; background: rgba(255, 255, 255, 0.1); border-radius: 50%;
            pointer-events: auto; border: 2px solid rgba(255,255,255,0.2); backdrop-filter: blur(2px); position: relative;
            display: none; 
        }
        #joystick-knob {
            width: 60px; height: 60px; background: rgba(255, 255, 255, 0.3); border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px rgba(255,255,255,0.1);
        }

        #dash-btn {
            width: 100px; height: 100px; background: rgba(255, 107, 107, 0.4); border: 4px solid rgba(255, 107, 107, 0.8);
            border-radius: 50%; pointer-events: auto; display: flex; align-items: center; justify-content: center;
            font-size: 40px; color: white; user-select: none; margin-top: 20px; transition: background 0.1s; cursor: pointer;
            margin-left: auto;
        }
        #dash-btn:active { background: rgba(255, 107, 107, 0.7); transform: scale(0.95); }
    </style>
</head>
<body>

    <div id="start-screen" class="screen">
        <h1>Hungry Kitty v2</h1>
        <p>Traverse the <b>City</b>, <b>Garden</b>, <b>Forest</b>, and <b>Tundra</b>.</p>
        <p>Goal: Reach the <b>Cozy Cabin</b> at the summit!</p>
        <div class="emoji-art">üê±üèôÔ∏èüå≤üèîÔ∏è</div>
        <div class="slider-container">
            <label for="diff-slider">Difficulty: <span id="diff-label" style="color:#a29bfe; font-weight:bold;">Normal</span></label><br>
            <input type="range" id="diff-slider" min="1" max="3" value="2" step="1" oninput="updateDiffLabel()">
        </div>
        <button id="start-btn" onclick="startGame()">Start Adventure</button>
    </div>

    <div id="fail-screen" class="screen hidden">
        <h1 style="color: #ff7675">CAUGHT!</h1>
        <div class="emoji-art">üôÄ</div>
        <p id="fail-msg">The dogs got you...</p>
        <button onclick="location.reload()">Try Again</button>
    </div>

    <div id="survival-screen" class="screen hidden">
        <h1 style="color: #fab1a0">WELL FED!</h1>
        <div class="emoji-art">üò∫üò∏üê∂</div>
        <p>Congratulations! You found food for the day!</p>
        <button onclick="location.reload()">Play Again</button>
    </div>

    <div id="win-screen" class="screen hidden">
        <h1 style="color: #ffeaa7">KITTY VALHALLA</h1>
        <div class="emoji-art">üî•üò∫üê∂üí§</div>
        <p>You and the puppy sleep cozy by the fire.</p>
        <button onclick="location.reload()">Rest Now</button>
    </div>

    <div id="ui-layer">
        <div id="hud">
            <span id="score-text">üêü 0/25</span>
            <span id="safety-msg">READY?</span>
        </div>
        <div id="stamina-container">
            <div id="stamina-label">ENERGY</div>
            <div id="stamina-fill"></div>
        </div>
        <div id="controls-layer">
            <div id="joystick-zone"><div id="joystick-knob"></div></div>
            <div id="dash-btn" onmousedown="startDash()" onmouseup="endDash()" ontouchstart="startDash()" ontouchend="endDash()">‚ö°</div>
        </div>
    </div>

    <div id="footer">Created by Arthur Fedderson &copy; Art4Tech 2025</div>
    <canvas id="gameCanvas"></canvas>

<script>
    const GAME_WIDTH = 2000;
    const GAME_HEIGHT = 6000; 
    
    const CONFIG = {
        city:   { dogs: 15, treats: 12, color: '#57606f' }, 
        grass:  { dogs: 12, treats: 10, color: '#2ecc71' },
        forest: { dogs: 20, treats: 8,  color: '#2c3e50' },
        snow:   { dogs: 25, treats: 6,  color: '#ecf0f1' }
    };

    let MAX_TREATS = 25;
    let DIFFICULTY = 2;

    let canvas, ctx, width, height;
    let gameActive = false, lastTime = 0, globalTime = 0, graceTimer = 3.0, score = 0;
    let camera = { x: 0, y: 0, zoom: 1.0 };
    let player = null; 
    let entities = []; 
    const input = { x: 0, y: 0, active: false };
    const keys = { w:false, a:false, s:false, d:false };
    let isDashing = false;
    let audioCtx, masterGain;
    let patterns = {};

    window.onload = () => {
        canvas = document.getElementById('gameCanvas');
        resize();
        ctx = canvas.getContext('2d', { alpha: false });
        window.addEventListener('resize', resize);
        setupInput();
        updateDiffLabel();
        if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.getElementById('joystick-zone').style.display = 'block';
            document.getElementById('dash-btn').style.marginLeft = '0'; 
        }
        generateTextures();
    };

    function generateTextures() {
        patterns.city = createPattern('#636e72', 'grid');
        patterns.grass = createPattern('#27ae60', 'noise');
        patterns.forest = createPattern('#0a3d62', 'leaf');
        patterns.snow = createPattern('#dfe6e9', 'crystal');
    }

    function createPattern(color, type) {
        const c = document.createElement('canvas');
        c.width = 100; c.height = 100;
        const x = c.getContext('2d');
        x.fillStyle = color;
        x.fillRect(0,0,100,100);
        x.fillStyle = 'rgba(0,0,0,0.1)';
        
        if(type === 'grid') { // City
            x.fillRect(0, 95, 100, 5); x.fillRect(95, 0, 5, 100);
        } else if (type === 'noise') { // Grass
            for(let i=0; i<50; i++) x.fillRect(Math.random()*100, Math.random()*100, 2, 2);
        } else if (type === 'leaf') { // Forest
            for(let i=0; i<20; i++) {
                x.beginPath(); x.arc(Math.random()*100, Math.random()*100, 4, 0, 6.28); x.fill();
            }
        } else { // Snow
            x.fillStyle = 'rgba(255,255,255,0.4)';
            for(let i=0; i<20; i++) {
                x.beginPath(); x.arc(Math.random()*100, Math.random()*100, 2, 0, 6.28); x.fill();
            }
        }
        return ctx.createPattern(c, 'repeat');
    }

    window.updateDiffLabel = function() {
        const val = document.getElementById('diff-slider').value;
        const label = document.getElementById('diff-label');
        const labels = ["Easy (Slow)", "Normal", "Hard (Fast)"];
        label.innerText = labels[val-1];
    }

    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        resize();
        DIFFICULTY = parseInt(document.getElementById('diff-slider').value);
        if(DIFFICULTY === 1) MAX_TREATS = 15;
        if(DIFFICULTY === 2) MAX_TREATS = 25;
        if(DIFFICULTY === 3) MAX_TREATS = 35;
        initWorld();
        try { initAudio(); } catch(e) {}
        gameActive = true;
        lastTime = Date.now();
        document.getElementById('safety-msg').style.opacity = 1;
        requestAnimationFrame(loop);
    }

    function resize() {
        width = window.innerWidth; height = window.innerHeight;
        if(canvas) { canvas.width = width; canvas.height = height; }
    }

    function initWorld() {
        entities = []; score = 0;
        let pSpeed = 4.0 + (DIFFICULTY * 0.5);
        player = {
            type: 'player',
            x: GAME_WIDTH / 2, y: GAME_HEIGHT - 200, z: 0,
            width: 30, height: 30, speed: pSpeed,
            vx: 0, vy: 0, angle: -Math.PI/2, state: 'idle',
            stamina: 100, maxStamina: 100, hidden: false
        };
        entities.push(player);

        spawnBiome(0, 1500, 'snow', CONFIG.snow);
        spawnBiome(1500, 3000, 'forest', CONFIG.forest);
        spawnBiome(3000, 4500, 'grass', CONFIG.grass);
        spawnBiome(4500, 6000, 'city', CONFIG.city);

        // Add Cabin ONLY, it will check visibility in Render
        entities.push({ type: 'cabin', x: GAME_WIDTH/2, y: 100, width: 120, height: 100 });
        
        document.getElementById('score-text').innerText = `üêü 0/${MAX_TREATS}`;
        camera.x = player.x; camera.y = player.y;
    }

    function spawnBiome(minY, maxY, type, settings) {
        let dogMult = (DIFFICULTY === 1) ? 0.6 : (DIFFICULTY === 3 ? 1.4 : 1.0);
        let count = Math.max(1, Math.floor(settings.dogs * dogMult)); 
        
        for(let i=0; i<25; i++) {
            let x = Math.random() * (GAME_WIDTH-100) + 50;
            let y = Math.random() * (maxY - minY) + minY;
            if(y > GAME_HEIGHT - 300) continue; 
            if(Math.random() > 0.6) {
                entities.push({ type: 'bush', biome: type, x: x, y: y, width: 60 });
            } else {
                let obsType = 'rock';
                if(type === 'city') obsType = (Math.random()>0.5 ? 'hydrant' : 'trash');
                if(type === 'forest') obsType = 'tree';
                entities.push({ type: 'obstacle', subtype: obsType, x: x, y: y, width: 30 });
            }
        }

        for(let i=0; i<count; i++) {
            let speedMod = (DIFFICULTY === 1) ? -0.5 : (DIFFICULTY === 3 ? 0.5 : 0);
            let baseSpd = 2.0 + speedMod;
            if(type === 'snow') baseSpd += 0.5; 
            let sight = (type === 'city' ? 250 : 350);

            entities.push({
                type: 'dog', biome: type,
                x: Math.random() * (GAME_WIDTH-100) + 50,
                y: Math.random() * (maxY - minY) + minY,
                speed: baseSpd, state: 'roam',
                angle: Math.random()*6.28,
                timer: 0, chaseTimer: 0, sniffTimer: 0,
                sightRange: sight,
                minY: minY, maxY: maxY // STRICT BIOME LIMITS
            });
        }

        let tCount = Math.max(5, Math.floor(settings.treats * (DIFFICULTY === 1 ? 0.8 : 1.2)));
        for(let i=0; i<tCount; i++) {
            entities.push({ type: 'treat', x: Math.random() * (GAME_WIDTH-100) + 50, y: Math.random() * (maxY - minY) + minY, z: 5, phase: Math.random()*Math.PI });
        }
    }

    function loop() {
        if(!gameActive) return;
        const now = Date.now();
        const dt = Math.min((now - lastTime)/1000, 0.1);
        lastTime = now;
        globalTime += dt;
        update(dt);
        render();
        requestAnimationFrame(loop);
    }

    function update(dt) {
        if(graceTimer > 0) {
            graceTimer -= dt;
            if(graceTimer <= 0) document.getElementById('safety-msg').style.opacity = 0;
            else document.getElementById('safety-msg').innerText = "SAFE: " + Math.ceil(graceTimer);
        }

        let dx = input.x; let dy = input.y;
        if(keys.w) dy = -1; if(keys.s) dy = 1; if(keys.a) dx = -1; if(keys.d) dx = 1;

        let currentSpeed = player.speed;
        if(isDashing && player.stamina > 0) {
            currentSpeed *= 1.8; player.stamina -= dt * 40; 
        } else {
            player.stamina = Math.min(player.maxStamina, player.stamina + dt * 10); 
        }
        
        document.getElementById('stamina-fill').style.width = player.stamina + "%";

        const len = Math.sqrt(dx*dx + dy*dy);
        if(len > 0) { dx/=len; dy/=len; }

        player.vx = dx * currentSpeed;
        player.vy = dy * currentSpeed;
        player.x += player.vx; player.y += player.vy;
        player.x = Math.max(20, Math.min(GAME_WIDTH-20, player.x));
        player.y = Math.max(20, Math.min(GAME_HEIGHT-20, player.y));

        if(Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
            player.angle = Math.atan2(dy, dx); player.state = 'run';
        } else { player.state = 'idle'; }

        let targetZ = 1.0;
        if(player.hidden) targetZ = 1.3; else if(player.state === 'run') targetZ = 0.8;
        camera.zoom += (targetZ - camera.zoom) * 0.02;
        camera.x += (player.x - camera.x) * 0.08; camera.y += (player.y - camera.y) * 0.08;

        player.hidden = false;
        let scoreUpdated = false;

        for(let e of entities) {
            if(e === player) continue;
            let dist = Math.hypot(player.x - e.x, player.y - e.y);

            if(e.type === 'bush') { if(dist < e.width/2) player.hidden = true; }

            if(e.type === 'obstacle' || e.type === 'cabin') {
                if(dist < e.width/2 + 10) {
                    let ang = Math.atan2(player.y - e.y, player.x - e.x);
                    player.x = e.x + Math.cos(ang) * (e.width/2 + 10);
                    player.y = e.y + Math.sin(ang) * (e.width/2 + 10);
                }
            }

            if(e.type === 'treat' && !e.collected) {
                if(dist < 35) { e.collected = true; score++; scoreUpdated = true; }
                e.z = 5 + Math.sin(globalTime*5 + e.phase)*3;
            }

            if(e.type === 'dog') {
                if(graceTimer > 0) continue;

                // BIOME LOCK
                if (e.y < e.minY + 20 || e.y > e.maxY - 20) {
                    // Force turn around
                    let centerBiome = (e.minY + e.maxY) / 2;
                    e.angle = Math.atan2(centerBiome - e.y, 0); // Point vertical towards center
                    e.x += Math.cos(e.angle) * e.speed;
                    e.y += Math.sin(e.angle) * e.speed;
                    continue; 
                }

                let canSee = (dist < e.sightRange);
                if(Math.abs(player.y - e.y) > 1000) canSee = false;
                
                // Stealth Logic
                if(player.hidden && e.state !== 'chase' && e.state !== 'sniff') canSee = false;

                if(canSee && e.state !== 'tired') {
                    // Hiding while chased logic
                    if(player.hidden && e.state === 'chase' && dist < 100) {
                        e.state = 'sniff'; e.sniffTimer = 1.5;
                    } 
                    else if(e.state === 'sniff') {
                        e.sniffTimer -= dt;
                        // If player is STILL hidden after timer, they get caught
                        if(e.sniffTimer <= 0) {
                            if(player.hidden) {
                                // Dive in!
                                e.state = 'chase';
                            } else {
                                // Player left?
                                e.state = 'chase';
                            }
                        }
                    }
                    else {
                        e.state = 'chase'; e.chaseTimer = 4.0;
                        let ang = Math.atan2(player.y - e.y, player.x - e.x);
                        e.x += Math.cos(ang) * e.speed;
                        e.y += Math.sin(ang) * e.speed;
                        e.angle = ang;
                    }

                    if(dist < 25 && e.state !== 'sniff') {
                        if(score >= MAX_TREATS) showScreen('survival'); else showFailScreen(player.y);
                    }
                } else {
                    e.state = 'roam'; e.timer -= dt;
                    if(e.timer <= 0) { e.timer = Math.random()*2 + 1; e.targetAngle = Math.random()*6.28; }
                    e.angle += (e.targetAngle - e.angle) * 0.1;
                    e.x += Math.cos(e.angle) * (e.speed * 0.5);
                    e.y += Math.sin(e.angle) * (e.speed * 0.5);
                }
            }
        }

        if(scoreUpdated) document.getElementById('score-text').innerText = `üêü ${score}/${MAX_TREATS}`;
        if(score >= MAX_TREATS && player.y < 200 && Math.abs(player.x - GAME_WIDTH/2) < 100) { showScreen('win'); }
        entities = entities.filter(e => !e.collected);
    }

    function render() {
        if(!player) return; 
        ctx.save();
        ctx.fillStyle = '#2d3436';
        ctx.fillRect(0,0,width,height);
        
        ctx.translate(width/2, height/2);
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x, -camera.y);

        // Textured Floors
        if(patterns.city) ctx.fillStyle = patterns.city; ctx.fillRect(0, 4500, GAME_WIDTH, 1500);
        if(patterns.grass) ctx.fillStyle = patterns.grass; ctx.fillRect(0, 3000, GAME_WIDTH, 1500);
        if(patterns.forest) ctx.fillStyle = patterns.forest; ctx.fillRect(0, 1500, GAME_WIDTH, 1500);
        if(patterns.snow) ctx.fillStyle = patterns.snow; ctx.fillRect(0, 0, GAME_WIDTH, 1500);

        // Road lines
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        for(let i=4600; i<6000; i+=200) ctx.fillRect(0, i, GAME_WIDTH, 20);

        entities.sort((a,b) => (a.y - b.y));

        for(let e of entities) {
            ctx.save();
            ctx.translate(e.x, e.y);
            
            // Shadows
            if(e.type !== 'treat' && e.type !== 'bush') {
                ctx.save(); ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.scale(1, 0.5);
                ctx.beginPath(); ctx.arc(0, 0, 15, 0, 6.28); ctx.fill(); ctx.restore();
            }

            if(e.type === 'player') drawKitty(e);
            else if(e.type === 'dog') drawDog(e);
            else if(e.type === 'treat') drawTreat(e);
            else if(e.type === 'bush') drawBush(e);
            else if(e.type === 'obstacle') drawObstacle(e);
            else if(e.type === 'cabin') {
                // Only draw cabin if score met
                if(score >= MAX_TREATS) drawCabin(e);
            }
            ctx.restore();
        }
        ctx.restore();
    }

    // --- NEW DRAWING (Distinct Visuals) ---
    function drawKitty(p) {
        if(p.hidden) ctx.globalAlpha = 0.5;
        
        // Outline
        ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
        
        let a = p.angle;
        let dir = 'right';
        if(a > -Math.PI*0.75 && a < -Math.PI*0.25) dir = 'up';
        else if(a > Math.PI*0.25 && a < Math.PI*0.75) dir = 'down';
        else if(Math.abs(a) > Math.PI*0.75) dir = 'left';

        // Legs (Paws)
        ctx.fillStyle = '#2d3436'; // Dark paw
        if(p.state === 'run') {
            let leg = Math.sin(globalTime*20)*6;
            ctx.beginPath(); ctx.arc(-14+leg, 8, 5, 0, 6.28); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(14-leg, 8, 5, 0, 6.28); ctx.fill(); ctx.stroke();
        } else {
            ctx.beginPath(); ctx.arc(-10, 8, 5, 0, 6.28); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(10, 8, 5, 0, 6.28); ctx.fill(); ctx.stroke();
        }

        // Tail
        let tailSide = (dir === 'left') ? 1 : -1;
        ctx.strokeStyle='#000'; ctx.lineWidth=6; ctx.lineCap='round';
        if(dir === 'up') { ctx.beginPath(); ctx.moveTo(0,5); ctx.quadraticCurveTo(0,20, Math.sin(globalTime*10)*5, 30); ctx.stroke(); }
        else if (dir !== 'down') { ctx.beginPath(); ctx.moveTo(10*tailSide, 5); ctx.quadraticCurveTo(25*tailSide, 10, 35*tailSide, 0); ctx.stroke(); }

        // Body
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.ellipse(0, 0, 16, 14, 0, 0, 6.28); ctx.fill();
        // Head
        ctx.beginPath(); ctx.arc(0, -12, 14, 0, 6.28); ctx.fill();

        // Ears
        ctx.beginPath(); 
        if(dir === 'up') { ctx.moveTo(-10,-18); ctx.lineTo(-14,-28); ctx.lineTo(-4,-20); ctx.moveTo(10,-18); ctx.lineTo(14,-28); ctx.lineTo(4,-20); } 
        else { ctx.moveTo(-12,-14); ctx.lineTo(-16,-24); ctx.lineTo(-6,-18); ctx.moveTo(12,-14); ctx.lineTo(16,-24); ctx.lineTo(6,-18); }
        ctx.fill();

        // Face
        if(dir !== 'up') {
            let ex = (dir === 'right' ? 6 : (dir === 'left' ? -6 : 5));
            let nx = (dir === 'right' ? 8 : (dir === 'left' ? -8 : 0));
            
            // Eyes (Green)
            ctx.fillStyle='#00b894';
            if(dir === 'down') { ctx.beginPath(); ctx.arc(-5, -14, 3, 0, 6.28); ctx.fill(); ctx.beginPath(); ctx.arc(5, -14, 3, 0, 6.28); ctx.fill(); } 
            else { ctx.beginPath(); ctx.arc(ex, -14, 3, 0, 6.28); ctx.fill(); }
            
            // Nose (Pink)
            ctx.fillStyle='#fd79a8'; ctx.beginPath(); ctx.arc(nx, -8, 3, 0, 6.28); ctx.fill();
            
            // Whiskers
            ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=1;
            if(dir === 'down') {
                ctx.beginPath(); ctx.moveTo(nx-2, -8); ctx.lineTo(nx-14, -10); ctx.stroke(); 
                ctx.beginPath(); ctx.moveTo(nx+2, -8); ctx.lineTo(nx+14, -10); ctx.stroke();
            } else {
                let wx = (dir === 'right') ? 1 : -1;
                ctx.beginPath(); ctx.moveTo(nx, -8); ctx.lineTo(nx+(12*wx), -11); ctx.stroke(); 
            }
        }
        ctx.globalAlpha = 1.0;
    }

    function drawDog(d) {
        // Outline
        ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1;

        let color = '#d35400'; // Grass (Orange)
        let dark = '#a04000';
        if(d.biome === 'city') { color = '#e1b12c'; dark = '#c0392b'; } // Pug
        if(d.biome === 'forest') { color = '#636e72'; dark = '#2d3436'; } // Wolf
        if(d.biome === 'snow') { color = '#dfe6e9'; dark = '#636e72'; } // Snow

        // Legs
        ctx.fillStyle = dark;
        let leg = Math.sin(globalTime*15 + d.x)*5;
        ctx.beginPath(); ctx.arc(-12+leg, 8, 4, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(12-leg, 8, 4, 0, 6.28); ctx.fill();

        // Body
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.ellipse(0, 0, 18, 14, 0, 0, 6.28); ctx.fill(); ctx.stroke();
        
        // Head
        ctx.beginPath(); ctx.arc(0, -12, 14, 0, 6.28); ctx.fill(); ctx.stroke();

        // Ears
        ctx.fillStyle = dark;
        if(d.biome === 'city') { // Small Pug Ears
            ctx.beginPath(); ctx.moveTo(-12,-20); ctx.lineTo(-16,-10); ctx.lineTo(-8,-10); ctx.fill();
            ctx.beginPath(); ctx.moveTo(12,-20); ctx.lineTo(16,-10); ctx.lineTo(8,-10); ctx.fill();
        } else if (d.biome === 'grass') { // Floppy
            ctx.beginPath(); ctx.ellipse(-14, -8, 5, 10, 0.3, 0, 6.28); ctx.fill();
            ctx.beginPath(); ctx.ellipse(14, -8, 5, 10, -0.3, 0, 6.28); ctx.fill();
        } else { // Pointy (Wolf)
            ctx.beginPath(); ctx.moveTo(-8,-22); ctx.lineTo(-12,-32); ctx.lineTo(-2,-22); ctx.fill();
            ctx.beginPath(); ctx.moveTo(8,-22); ctx.lineTo(12,-32); ctx.lineTo(2,-22); ctx.fill();
        }

        // Snout
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.beginPath(); ctx.ellipse(0, -8, 8, 6, 0, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, -8, 3, 0, 6.28); ctx.fill(); // Nose Tip

        // Eyes
        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(-5, -16, 2, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(5, -16, 2, 0, 6.28); ctx.fill();

        if(d.state === 'sniff') { ctx.font = '24px serif'; ctx.fillText('?', 0, -35); }
        if(d.state === 'chase') { ctx.font = '24px serif'; ctx.fillText('!', 0, -35); }
    }

    function drawObstacle(e) {
        if(e.subtype === 'hydrant') {
            ctx.fillStyle = '#e74c3c'; ctx.fillRect(-10, -20, 20, 25);
            ctx.beginPath(); ctx.arc(0, -20, 10, 0, Math.PI, true); ctx.fill();
            ctx.fillStyle = '#c0392b'; ctx.fillRect(-5, -15, 10, 5); 
        } else if (e.subtype === 'trash') {
            ctx.fillStyle = '#b2bec3'; ctx.fillRect(-12, -20, 24, 25);
            ctx.strokeStyle = '#636e72'; ctx.lineWidth = 2; ctx.strokeRect(-12,-20,24,25);
        } else if (e.subtype === 'rock') {
            ctx.fillStyle = '#636e72'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, 6.28); ctx.fill();
        } else if (e.subtype === 'tree') {
            ctx.fillStyle = '#2d3436'; ctx.fillRect(-5, -10, 10, 15); 
            ctx.fillStyle = '#00b894'; 
            ctx.beginPath(); ctx.moveTo(0, -50); ctx.lineTo(-20, -10); ctx.lineTo(20, -10); ctx.fill();
            ctx.beginPath(); ctx.moveTo(0, -70); ctx.lineTo(-15, -30); ctx.lineTo(15, -30); ctx.fill();
        }
    }

    function drawBush(e) {
        ctx.fillStyle = '#16a085'; ctx.beginPath(); ctx.arc(0, 0, 30, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#1abc9c'; ctx.beginPath(); ctx.arc(-10, -10, 15, 0, 6.28); ctx.fill();
    }

    function drawTreat(e) {
        ctx.translate(0, -e.z);
        ctx.font = "30px serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText("üêü", 0, 0);
    }

    function drawCabin(e) {
        ctx.fillStyle = "#6d4c41"; ctx.fillRect(-60, -60, 120, 60);
        ctx.fillStyle = "#d35400"; ctx.beginPath(); ctx.moveTo(-70, -60); ctx.lineTo(70, -60); ctx.lineTo(0, -110); ctx.fill();
        ctx.fillStyle = "#2d3436"; ctx.fillRect(-15, -60, 30, 40);
    }

    function startDash() { isDashing = true; }
    function endDash() { isDashing = false; }

    function showScreen(id) {
        gameActive = false;
        document.getElementById(id).classList.remove('hidden');
    }

    function showFailScreen(y) {
        gameActive = false;
        let msg = "The wild claimed you...";
        if(y > 4500) msg = "The city dogs were too fast...";
        else if(y > 3000) msg = "The garden pups caught you...";
        else if(y > 1500) msg = "The forest wolves found you...";
        else msg = "The tundra wolves claimed you...";
        
        document.getElementById('fail-msg').innerText = msg;
        document.getElementById('fail-screen').classList.remove('hidden');
    }

    function setupInput() {
        const joy = document.getElementById('joystick-zone');
        joy.addEventListener('touchstart', e => { e.preventDefault(); input.active = true; handleJoy(e.touches[0]); });
        joy.addEventListener('touchmove', e => { e.preventDefault(); if(input.active) handleJoy(e.touches[0]); });
        joy.addEventListener('touchend', e => { e.preventDefault(); input.active = false; input.x=0; input.y=0; updateJoyVis(0,0); });
        
        window.addEventListener('keydown', e => {
            if(e.code === 'Space') isDashing = true;
            if(e.key === 'w') keys.w = true; if(e.key === 'a') keys.a = true;
            if(e.key === 's') keys.s = true; if(e.key === 'd') keys.d = true;
        });
        window.addEventListener('keyup', e => {
            if(e.code === 'Space') isDashing = false;
            if(e.key === 'w') keys.w = false; if(e.key === 'a') keys.a = false;
            if(e.key === 's') keys.s = false; if(e.key === 'd') keys.d = false;
        });
    }

    function handleJoy(touch) {
        const r = document.getElementById('joystick-zone').getBoundingClientRect();
        let dx = touch.clientX - (r.left + r.width/2);
        let dy = touch.clientY - (r.top + r.height/2);
        const dist = Math.sqrt(dx*dx + dy*dy);
        const max = 50;
        if(dist > max) { dx = (dx/dist)*max; dy = (dy/dist)*max; }
        input.x = dx/max; input.y = dy/max;
        updateJoyVis(dx, dy);
    }

    function updateJoyVis(x, y) {
        document.getElementById('joystick-knob').style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
    }

    function initAudio() { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    function playCrunchSound() { if(!audioCtx) return; let o=audioCtx.createOscillator(); let g=audioCtx.createGain(); o.type='square'; o.frequency.setValueAtTime(400, audioCtx.currentTime); g.gain.setValueAtTime(0.1, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.1); o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+0.1); }
</script>
</body>
</html>